import Mathlib.LinearAlgebra.LinearIndependent.Defs
import Mathlib.LinearAlgebra.Finsupp.LinearCombination
import Mathlib.LinearAlgebra.Span.Basic
import QEC.Stabilizer.BinarySymplectic.Core
import QEC.Stabilizer.BinarySymplectic.SymplecticInner
import QEC.Stabilizer.BinarySymplectic.CheckMatrix
import QEC.Stabilizer.Core.SubgroupLemmas
import QEC.Stabilizer.PauliGroup.NQubitElement

namespace Quantum

open scoped BigOperators
open Submodule
open NQubitPauliOperator

variable {n : ℕ}

/-!
# From row independence to independent generators

For a list `L` of n-qubit Pauli group elements:
- **Subgroup.IndependentGenerators (listToSet L)**: no element of `L` lies in the subgroup
  generated by the others.
- **NQubitPauliGroupElement.rowsLinearIndependent L**: the rows of the check matrix (symplectic
  vectors) are linearly independent over ZMod 2.

**Forward implication:** If the check-matrix rows are linearly independent, then the set of
elements is an independent generating set. This is the direction used to prove that stabilizer
code generators (e.g. repetition code, Steane) are independent: show `rowsLinearIndependent L`,
then deduce `Subgroup.IndependentGenerators (listToSet L)`.

**Note:** The reverse implication is false in general. For example, the 1-qubit list `[X, Y, Z]`
has no duplicates and is an independent generating set, but its check-matrix rows are linearly
dependent over ZMod 2.
-/

namespace NQubitPauliGroupElement

/-- The set of elements appearing in the list `L`. -/
def listToSet (L : List (NQubitPauliGroupElement n)) : Set (NQubitPauliGroupElement n) :=
  setOf (· ∈ L)

/-- Every element of the list has phase 0 (no global phase factor i, -1, or -i). -/
def AllPhaseZero (L : List (NQubitPauliGroupElement n)) : Prop :=
  ∀ g ∈ L, g.phasePower = 0

/-- If the check-matrix rows of `L` are linearly independent, then the set of elements is an
  independent generating set. Use this to prove that code generator lists (e.g. `generatorsList`
  for RepetitionCode3 or Steane7) satisfy `Subgroup.IndependentGenerators (listToSet L)` by
  first proving `rowsLinearIndependent L`. -/
theorem rowsLinearIndependent_implies_independentGenerators (L : List (NQubitPauliGroupElement n))
    (h : rowsLinearIndependent L) :
    Subgroup.IndependentGenerators (listToSet L) := by
  intro g hg
  obtain ⟨i, hi⟩ : ∃ i : Fin L.length, g = L.get i := by
    obtain ⟨i, hi⟩ := List.mem_iff_get.mp hg
    exact ⟨i, hi.symm⟩
  by_contra h_contra
  -- g ∈ closure (listToSet L \ {g}) ⇒ toSymplectic g.operators ∈ span of symplectic image
  -- of (listToSet L \ {g})
  have h_symplectic :
      toSymplectic (L.get i).operators ∈
        span (ZMod 2) ((fun g' => toSymplectic g'.operators) '' (listToSet L \ {g})) := by
    rw [← hi]
    exact Quantum.toSymplectic_mem_span_of_mem_closure h_contra
  -- That span is contained in the span of rows j ≠ i (listToSet L \ {g} ⊆ image of indices ≠ i)
  have h_span_subset :
      (fun g' => toSymplectic g'.operators) '' (listToSet L \ {g}) ⊆
        (fun j => checkMatrix L j) '' (↑(Finset.univ.erase i) : Set (Fin L.length)) := by
    intro x hx
    obtain ⟨y, hy, rfl⟩ := hx
    rw [listToSet, Set.mem_diff, Set.mem_setOf] at hy
    obtain ⟨hy_mem, hy_ne⟩ := hy
    obtain ⟨j, hj⟩ := List.mem_iff_get.mp hy_mem
    refine ⟨j, Finset.mem_erase.mpr ⟨?_, Finset.mem_univ j⟩, ?_⟩
    · rintro rfl
      exact hy_ne (hj.symm.trans hi.symm)
    · rw [← hj]
      rfl
  have h_in_span_erase :
      checkMatrix L i ∈
        span (ZMod 2)
          ((fun j => checkMatrix L j) '' (↑(Finset.univ.erase i) : Set (Fin L.length))) :=
    by
    rw [show checkMatrix L i = toSymplectic (L.get i).operators from by ext j; rfl]
    exact span_mono h_span_subset h_symplectic
  rw [Finsupp.mem_span_image_iff_linearCombination (R := ZMod 2) (v := checkMatrix L)
    ] at h_in_span_erase
  obtain ⟨l, hl_supp, hl_eq⟩ := h_in_span_erase
  -- l is supported on indices ≠ i, so l i = 0; then l' := single i 1 + l has combination 0
  -- but l' ≠ 0
  have hi_not_mem : i ∉ (Finset.univ.erase i : Set (Fin L.length)) := by simp
  have li_zero : l i = 0 :=
    by
      exact Finsupp.notMem_support_iff.mp fun a ↦ hi_not_mem (hl_supp a)
  set l' := Finsupp.single i (1 : ZMod 2) + l with hl'
  have h_comb_zero : Finsupp.linearCombination (ZMod 2) (checkMatrix L) l' = 0 := by
    rw [LinearMap.map_add, Finsupp.linearCombination_single, hl_eq, one_smul,
      ← two_smul (ZMod 2) (checkMatrix L i)]
    norm_num
    -- Since we're working in ZMod 2, 2 is equivalent to 0.
    left; norm_cast
  have l'_ne_zero : l' ≠ 0 := by
    rw [Finsupp.ne_iff]
    use i
    simp only [hl', Finsupp.add_apply, Finsupp.single_eq_same, li_zero]
    exact not_eq_of_beq_eq_false rfl
  have heq := h.finsuppLinearCombination_injective (h_comb_zero.trans (LinearMap.map_zero _).symm)
  exact l'_ne_zero heq

end NQubitPauliGroupElement

end Quantum
