import QEC.Stabilizer.BinarySymplectic.Core
import QEC.Stabilizer.BinarySymplectic.CheckMatrix
import QEC.Stabilizer.BinarySymplectic.CheckMatrixDecidable
import QEC.Stabilizer.BinarySymplectic.SymplecticSpan
import QEC.Stabilizer.Core.StabilizerCode
import QEC.Stabilizer.Core.CodeDistance
import QEC.Stabilizer.PauliGroup.Commutation
import QEC.Stabilizer.PauliGroup.CommutationTactics
import QEC.Stabilizer.Core.StabilizerGroup
import QEC.Stabilizer.Core.SubgroupLemmas
import QEC.Stabilizer.Core.CSSNoNegI
import QEC.Stabilizer.Core.Centralizer
import QEC.Stabilizer.PauliGroup.NQubitOperator
import QEC.Stabilizer.PauliGroup.NQubitElement

namespace Quantum
open scoped BigOperators

namespace StabilizerGroup
namespace RepetitionCode3

/-!
# The 3-qubit repetition code (Z-stabilizer only)

Stabilizer generators: Z₁Z₂ and Z₂Z₃ (Z on adjacent pairs). The code encodes one logical qubit;
logical X = X₁X₂X₃, logical Z = Z₁Z₂Z₃. The subgroup is abelian and does not contain −I.
-/

/-- Z₁Z₂: Z on qubits 0 and 1, I on qubit 2. -/
def Z1Z2 : NQubitPauliGroupElement 3 :=
  ⟨0, ((NQubitPauliOperator.identity 3).set 0 PauliOperator.Z).set 1 PauliOperator.Z⟩

/-- Z₂Z₃: I on qubit 0, Z on qubits 1 and 2. -/
def Z2Z3 : NQubitPauliGroupElement 3 :=
  ⟨0, ((NQubitPauliOperator.identity 3).set 1 PauliOperator.Z).set 2 PauliOperator.Z⟩

/-- The generator set for the 3-qubit repetition-code stabilizer subgroup. -/
def generators : Set (NQubitPauliGroupElement 3) :=
  {Z1Z2, Z2Z3}

/-- Generators as a list (for symplectic-span arguments). -/
def generatorsList : List (NQubitPauliGroupElement 3) :=
  [Z1Z2, Z2Z3]

/-- The list of generators has the same elements as the generator set. -/
lemma listToSet_generatorsList : NQubitPauliGroupElement.listToSet generatorsList = generators := by
  ext g
  simp only [NQubitPauliGroupElement.listToSet, Set.mem_setOf, generatorsList, generators,
    List.mem_cons, List.mem_nil_iff, or_false, Set.mem_insert_iff, Set.mem_singleton_iff]

/-- Every element of the generators list has phase power 0. -/
lemma AllPhaseZero_generatorsList : NQubitPauliGroupElement.AllPhaseZero generatorsList := by
  intro g hg
  simp only [generatorsList, List.mem_cons, List.mem_nil_iff, or_false] at hg
  rcases hg with rfl | rfl <;> rfl

/-- The check-matrix rows of the repetition-code generators are linearly independent. -/
theorem rowsLinearIndependent_generatorsList :
    NQubitPauliGroupElement.rowsLinearIndependent generatorsList := by decide

/-- The repetition-code generator list is an independent generating set. -/
theorem GeneratorsIndependent_3_generatorsList : GeneratorsIndependent 3 generatorsList :=
  GeneratorsIndependent_of_rowsLinearIndependent 3 generatorsList
    rowsLinearIndependent_generatorsList

/-- The generators commute (proved componentwise). -/
lemma Z1Z2_commutes_Z2Z3 : Z1Z2 * Z2Z3 = Z2Z3 * Z1Z2 := by
  pauli_comm_componentwise [Z1Z2, Z2Z3]

/-- Pairwise commutation for elements of `generators`. -/
theorem generators_commute :
    ∀ g ∈ generators, ∀ h ∈ generators, g * h = h * g := by
  classical
  intro g hg h hh
  simp [generators] at hg hh
  rcases hg with rfl | rfl <;> rcases hh with rfl | rfl
  · rfl
  · exact Z1Z2_commutes_Z2Z3
  · simpa using Z1Z2_commutes_Z2Z3.symm
  · rfl

/-- The subgroup generated by the repetition-code generators. -/
def subgroup : Subgroup (NQubitPauliGroupElement 3) :=
  Subgroup.closure generators

/-- Example usage: the generated subgroup is abelian, via `SubgroupLemmas`. -/
theorem subgroup_is_abelian :
    ∀ g ∈ subgroup, ∀ h ∈ subgroup, g * h = h * g := by
  -- `subgroup` is definitionaly `Subgroup.closure generators`.
  simpa [subgroup] using
    (Subgroup.abelian_closure_of_pairwise_commute (G := NQubitPauliGroupElement 3)
      generators generators_commute)

/-!
## No `-I` in the generated subgroup

This is a special case of the reusable CSS lemma with:
- Z-generators = `generators`
- X-generators = `∅`
-/

open NQubitPauliGroupElement

/-- Each generator is Z-type (I or Z on each qubit). -/
lemma generators_are_ZType :
    ∀ g, g ∈ generators → NQubitPauliGroupElement.IsZTypeElement g := by
  classical
  intro g hg
  rcases (by simpa [generators] using hg) with rfl | rfl <;>
    · constructor
      · rfl
      · intro i
        fin_cases i <;>
          simp [PauliOperator.IsZType, Z1Z2, Z2Z3, NQubitPauliOperator.set,
            NQubitPauliOperator.identity]

/-- The repetition-code subgroup does not contain −I (CSS lemma with empty X-generators). -/
lemma negIdentity_not_mem :
    negIdentity 3 ∉ subgroup := by
  -- Apply the generic CSS `-I` exclusion theorem with empty X-generators.
  have hX : ∀ x, x ∈ (∅ : Set (NQubitPauliGroupElement 3)) → IsXTypeElement x := by
    intro x hx; cases hx
  have hZX : ∀ z ∈ generators, ∀ x ∈ (∅ : Set (NQubitPauliGroupElement 3)), z * x = x * z := by
    intro z hz x hx; cases hx
  simpa [subgroup] using
    (CSS.negIdentity_not_mem_closure_union (n := 3) generators (∅ : Set (NQubitPauliGroupElement 3))
      generators_are_ZType hX hZX)

/-- The 3-qubit repetition code as a stabilizer group: abelian closure of Z₁Z₂ and Z₂Z₃, no −I. -/
noncomputable def stabilizerGroup : StabilizerGroup 3 :=
{ toSubgroup := subgroup
, is_abelian := by
    intro g h hg hh
    exact subgroup_is_abelian g hg h hh
, no_neg_identity := by
    simpa using negIdentity_not_mem }

/-!
## Logical operators
-/

/-- Logical X: X on all three qubits (X₁X₂X₃). -/
def logicalX : NQubitPauliGroupElement 3 :=
  ⟨0, NQubitPauliOperator.X 3⟩

/-- Logical Z: Z on all three qubits (Z₁Z₂Z₃). -/
def logicalZ : NQubitPauliGroupElement 3 :=
  ⟨0, NQubitPauliOperator.Z 3⟩

/-- Logical X and logical Z anticommute: X₁X₂X₃ and Z₁Z₂Z₃ anticommute at every qubit. -/
theorem logicalX_anticommutes_logicalZ : NQubitPauliGroupElement.Anticommute logicalX logicalZ :=
  NQubitPauliOperator.allX_allZ_anticommute 3 (by decide)

private lemma logicalX_commutes_Z1Z2 : logicalX * Z1Z2 = Z1Z2 * logicalX := by
  classical
  pauli_comm_even_anticommutes
  have hfilter :
      (Finset.univ.filter
            (NQubitPauliGroupElement.anticommutesAt (n := 3) logicalX.operators Z1Z2.operators)) =
        ({0, 1} : Finset (Fin 3)) := by
    ext i; fin_cases i <;>
      simp [Finset.mem_filter, NQubitPauliGroupElement.anticommutesAt, logicalX, Z1Z2,
        NQubitPauliOperator.X, NQubitPauliOperator.set, NQubitPauliOperator.identity,
        PauliOperator.mulOp]
  simp [hfilter]

private lemma logicalX_commutes_Z2Z3 : logicalX * Z2Z3 = Z2Z3 * logicalX := by
  classical
  pauli_comm_even_anticommutes
  have hfilter :
      (Finset.univ.filter
            (NQubitPauliGroupElement.anticommutesAt (n := 3) logicalX.operators Z2Z3.operators)) =
        ({1, 2} : Finset (Fin 3)) := by
    ext i; fin_cases i <;>
      simp [Finset.mem_filter, NQubitPauliGroupElement.anticommutesAt, logicalX, Z2Z3,
        NQubitPauliOperator.X, NQubitPauliOperator.set, NQubitPauliOperator.identity,
        PauliOperator.mulOp]
  simp [hfilter]

/-- Logical X commutes with every element of the stabilizer. -/
theorem logicalX_mem_centralizer : logicalX ∈ centralizer stabilizerGroup := by
  rw [StabilizerGroup.mem_centralizer_iff]
  intro h hh
  refine Subgroup.closure_induction (p := fun g _ => g * logicalX = logicalX * g)
    (fun g hg => ?_)
    (by simp only [NQubitPauliGroupElement.one_mul, NQubitPauliGroupElement.mul_one])
    (fun x y _ _ hx hy => ?_) (fun x _ h => ?_) hh
  · simp [generators] at hg
    rcases hg with rfl | rfl
    · exact logicalX_commutes_Z1Z2.symm
    · exact logicalX_commutes_Z2Z3.symm
  · calc (x * y) * logicalX = x * (y * logicalX) := by rw [NQubitPauliGroupElement.mul_assoc]
    _ = x * (logicalX * y) := by rw [hy]
    _ = (x * logicalX) * y := by rw [← NQubitPauliGroupElement.mul_assoc]
    _ = (logicalX * x) * y := by rw [hx]
    _ = logicalX * (x * y) := by rw [NQubitPauliGroupElement.mul_assoc]
  · have H : (x⁻¹ * logicalX) * x = (logicalX * x⁻¹) * x := by
      rw [NQubitPauliGroupElement.mul_assoc, ← h, inv_mul_cancel_left,
        NQubitPauliGroupElement.mul_assoc, inv_mul_cancel, NQubitPauliGroupElement.mul_one]
    exact mul_right_cancel H

/-- Logical X is X-type (X on every qubit). -/
lemma logicalX_is_XType : NQubitPauliGroupElement.IsXTypeElement logicalX := by
  constructor
  · rfl
  · intro i
    fin_cases i <;> simp [logicalX, NQubitPauliOperator.X, PauliOperator.IsXType]

private lemma logicalZ_commutes_Z1Z2 : logicalZ * Z1Z2 = Z1Z2 * logicalZ := by
  pauli_comm_componentwise [logicalZ, Z1Z2]
  all_goals simp only [NQubitPauliOperator.Z]

private lemma logicalZ_commutes_Z2Z3 : logicalZ * Z2Z3 = Z2Z3 * logicalZ := by
  pauli_comm_componentwise [logicalZ, Z2Z3]
  all_goals simp only [NQubitPauliOperator.Z]

/-- Logical Z commutes with every element of the stabilizer. -/
theorem logicalZ_mem_centralizer : logicalZ ∈ centralizer stabilizerGroup := by
  rw [StabilizerGroup.mem_centralizer_iff]
  intro h hh
  refine Subgroup.closure_induction (p := fun g _ => g * logicalZ = logicalZ * g)
    (fun g hg => ?_)
    (by simp only [NQubitPauliGroupElement.one_mul, NQubitPauliGroupElement.mul_one])
    (fun x y _ _ hx hy => ?_) (fun x _ h => ?_) hh
  · simp [generators] at hg
    rcases hg with rfl | rfl
    · exact logicalZ_commutes_Z1Z2.symm
    · exact logicalZ_commutes_Z2Z3.symm
  · calc (x * y) * logicalZ = x * (y * logicalZ) := by rw [NQubitPauliGroupElement.mul_assoc]
    _ = x * (logicalZ * y) := by rw [hy]
    _ = (x * logicalZ) * y := by rw [← NQubitPauliGroupElement.mul_assoc]
    _ = (logicalZ * x) * y := by rw [hx]
    _ = logicalZ * (x * y) := by rw [NQubitPauliGroupElement.mul_assoc]
  · have H : (x⁻¹ * logicalZ) * x = (logicalZ * x⁻¹) * x := by
      rw [NQubitPauliGroupElement.mul_assoc, ← h, inv_mul_cancel_left,
        NQubitPauliGroupElement.mul_assoc, inv_mul_cancel, NQubitPauliGroupElement.mul_one]
    exact mul_right_cancel H

/-!
## StabilizerCode [[3, 1]]
-/

/-- The 3-qubit repetition code as a stabilizer code [[3, 1]]: one logical qubit. -/
noncomputable def stabilizerCode : StabilizerCode 3 1 where
  hk := by decide
  toStabilizerGroup := stabilizerGroup
  generatorsList := generatorsList
  subgroup_eq_closure := by rw [listToSet_generatorsList]; simp only [stabilizerGroup]; rfl
  generators_length := rfl
  generators_phaseZero := AllPhaseZero_generatorsList
  generators_independent := GeneratorsIndependent_3_generatorsList
  logicalX := fun _ => logicalX
  logicalZ := fun _ => logicalZ
  logicalX_mem_centralizer := fun _ => logicalX_mem_centralizer
  logicalZ_mem_centralizer := fun _ => logicalZ_mem_centralizer
  logicalX_anticommute_logicalZ := fun _ => logicalX_anticommutes_logicalZ
  logical_commute_cross := fun ℓ ℓ' h => (h (Subsingleton.elim ℓ ℓ')).elim

/-!
## Code distance [[3, 1, 1]]

The repetition code has distance 1: a single Z on any physical qubit is a nontrivial logical
(same coset as logical Z). So the minimum weight of a nontrivial logical is 1.
-/

open NQubitPauliOperator NQubitPauliGroupElement

/-- Z on qubit 2 only (I on qubits 0 and 1). -/
def Z_on_qubit2 : NQubitPauliGroupElement 3 :=
  ⟨0, (NQubitPauliOperator.identity 3).set 2 PauliOperator.Z⟩

lemma Z_on_qubit2_operators (i : Fin 3) :
    Z_on_qubit2.operators i = if i = 2 then PauliOperator.Z else PauliOperator.I := by
  simp only [Z_on_qubit2, NQubitPauliOperator.set, NQubitPauliOperator.identity]

/-- Z_on_qubit2 has weight 1. -/
lemma weight_Z_on_qubit2 : NQubitPauliGroupElement.weight Z_on_qubit2 = 1 := by
  have h : NQubitPauliOperator.support Z_on_qubit2.operators = {2} := by
    ext i
    simp only [NQubitPauliOperator.mem_support, Z_on_qubit2_operators, Finset.mem_singleton]
    split_ifs with h <;> simp [h]
  rw [NQubitPauliGroupElement.weight, NQubitPauliOperator.weight, h]
  simp only [Finset.card_singleton]

private lemma Z_on_qubit2_commutes_Z1Z2 : Z_on_qubit2 * Z1Z2 = Z1Z2 * Z_on_qubit2 := by
  pauli_comm_componentwise [Z_on_qubit2, Z1Z2]

private lemma Z_on_qubit2_commutes_Z2Z3 : Z_on_qubit2 * Z2Z3 = Z2Z3 * Z_on_qubit2 := by
  pauli_comm_componentwise [Z_on_qubit2, Z2Z3]

/-- Z_on_qubit2 is in the centralizer of the repetition-code stabilizer. -/
lemma Z_on_qubit2_mem_centralizer : Z_on_qubit2 ∈ centralizer stabilizerGroup := by
  rw [StabilizerGroup.mem_centralizer_iff]
  intro h hh
  refine Subgroup.closure_induction (p := fun g _ => g * Z_on_qubit2 = Z_on_qubit2 * g)
    (fun g hg => ?_)
    (by simp only [NQubitPauliGroupElement.one_mul, NQubitPauliGroupElement.mul_one])
    (fun x y _ _ hx hy => ?_) (fun x _ h => ?_) hh
  · simp [generators] at hg
    rcases hg with rfl | rfl
    · exact Z_on_qubit2_commutes_Z1Z2.symm
    · exact Z_on_qubit2_commutes_Z2Z3.symm
  · calc (x * y) * Z_on_qubit2 = x * (y * Z_on_qubit2) := by rw [NQubitPauliGroupElement.mul_assoc]
      _ = x * (Z_on_qubit2 * y) := by rw [hy]
      _ = (x * Z_on_qubit2) * y := by rw [← NQubitPauliGroupElement.mul_assoc]
      _ = (Z_on_qubit2 * x) * y := by rw [hx]
      _ = Z_on_qubit2 * (x * y) := by rw [NQubitPauliGroupElement.mul_assoc]
  · have H : (x⁻¹ * Z_on_qubit2) * x = (Z_on_qubit2 * x⁻¹) * x := by
      rw [NQubitPauliGroupElement.mul_assoc, ← h, inv_mul_cancel_left,
        NQubitPauliGroupElement.mul_assoc, inv_mul_cancel, NQubitPauliGroupElement.mul_one]
    exact mul_right_cancel H

/-- Z_on_qubit2 anticommutes with logical X (overlap only on qubit 2, where X and Z anticommute). -/
lemma Z_on_qubit2_anticommutes_logicalX :
    NQubitPauliGroupElement.Anticommute Z_on_qubit2 logicalX := by
  classical
  rw [NQubitPauliGroupElement.anticommutes_iff_odd_anticommutes]
  have hfilter :
      (Finset.univ.filter
          (NQubitPauliGroupElement.anticommutesAt (n := 3) Z_on_qubit2.operators
            logicalX.operators)) = ({2} : Finset (Fin 3)) := by
    ext i
    fin_cases i <;>
      simp [Finset.mem_filter, NQubitPauliGroupElement.anticommutesAt, Z_on_qubit2_operators,
        logicalX, NQubitPauliOperator.X, PauliOperator.mulOp]
  rw [hfilter]
  decide

/-- Z_on_qubit2 is not in the stabilizer: it anticommutes with logical X (in the centralizer). -/
lemma Z_on_qubit2_not_mem_subgroup : Z_on_qubit2 ∉ subgroup :=
  not_mem_stabilizer_of_anticommutes_centralizer stabilizerGroup Z_on_qubit2 logicalX
    logicalX_mem_centralizer Z_on_qubit2_anticommutes_logicalX

/-- Z_on_qubit2 is a nontrivial logical operator of weight 1. -/
lemma Z_on_qubit2_nontrivial_logical :
    IsNontrivialLogicalOperator Z_on_qubit2 stabilizerGroup :=
  ⟨Z_on_qubit2_mem_centralizer, by simp only [stabilizerGroup]; exact Z_on_qubit2_not_mem_subgroup⟩

/-- The 3-qubit repetition code has code distance 1. -/
theorem repetitionCode3_has_distance_one : HasCodeDistance stabilizerCode 1 := by
  refine ⟨by decide, ?_, ⟨Z_on_qubit2, Z_on_qubit2_nontrivial_logical, weight_Z_on_qubit2⟩⟩
  intro g _ hw
  exact Nat.one_le_of_lt hw

/-- The minimum weight of a nontrivial logical operator for the repetition code is 1. -/
theorem repetitionCode3_min_weight_nontrivial_logical (g : NQubitPauliGroupElement 3)
    (hg : IsNontrivialLogicalOperator g stabilizerGroup)
    (hw : 0 < NQubitPauliGroupElement.weight g) :
    NQubitPauliGroupElement.weight g ≥ 1 :=
  HasCodeDistance.min_weight stabilizerCode 1 repetitionCode3_has_distance_one g hg
    hw

end RepetitionCode3
end StabilizerGroup

end Quantum
