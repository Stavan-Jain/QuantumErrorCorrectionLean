import QEC.Stabilizer.BinarySymplectic.Core
import QEC.Stabilizer.BinarySymplectic.CheckMatrix
import QEC.Stabilizer.BinarySymplectic.SymplecticSpan
import QEC.Stabilizer.PauliGroup.Commutation
import QEC.Stabilizer.PauliGroup.CommutationTactics
import QEC.Stabilizer.Core.StabilizerGroup
import QEC.Stabilizer.Core.SubgroupLemmas
import QEC.Stabilizer.Core.CSSNoNegI
import QEC.Stabilizer.Core.Centralizer
import QEC.Stabilizer.PauliGroup.NQubitOperator

namespace Quantum
open scoped BigOperators

namespace StabilizerGroup
namespace RepetitionCode3

/-!
# The 3-qubit repetition code (Z-stabilizer only)

Stabilizer generators: Z₁Z₂ and Z₂Z₃ (Z on adjacent pairs). The code encodes one logical qubit;
logical X = X₁X₂X₃, logical Z = Z₁Z₂Z₃. The subgroup is abelian and does not contain −I.
-/

/-- Z₁Z₂: Z on qubits 0 and 1, I on qubit 2. -/
def Z1Z2 : NQubitPauliGroupElement 3 :=
  ⟨0, ((NQubitPauliOperator.identity 3).set 0 PauliOperator.Z).set 1 PauliOperator.Z⟩

/-- Z₂Z₃: I on qubit 0, Z on qubits 1 and 2. -/
def Z2Z3 : NQubitPauliGroupElement 3 :=
  ⟨0, ((NQubitPauliOperator.identity 3).set 1 PauliOperator.Z).set 2 PauliOperator.Z⟩

/-- The generator set for the 3-qubit repetition-code stabilizer subgroup. -/
def generators : Set (NQubitPauliGroupElement 3) :=
  {Z1Z2, Z2Z3}

/-- Generators as a list (for symplectic-span arguments). -/
def generatorsList : List (NQubitPauliGroupElement 3) :=
  [Z1Z2, Z2Z3]

/-- The list of generators has the same elements as the generator set. -/
lemma listToSet_generatorsList : NQubitPauliGroupElement.listToSet generatorsList = generators := by
  ext g
  simp only [NQubitPauliGroupElement.listToSet, Set.mem_setOf, generatorsList, generators,
    List.mem_cons, List.mem_nil_iff, or_false, Set.mem_insert_iff, Set.mem_singleton_iff]

/-- Every element of the generators list has phase power 0. -/
lemma AllPhaseZero_generatorsList : NQubitPauliGroupElement.AllPhaseZero generatorsList := by
  intro g hg
  simp only [generatorsList, List.mem_cons, List.mem_nil_iff, or_false] at hg
  rcases hg with rfl | rfl <;> rfl

/-- The generators commute (proved componentwise). -/
lemma Z1Z2_commutes_Z2Z3 : Z1Z2 * Z2Z3 = Z2Z3 * Z1Z2 := by
  pauli_comm_componentwise [Z1Z2, Z2Z3]

/-- Pairwise commutation for elements of `generators`. -/
theorem generators_commute :
    ∀ g ∈ generators, ∀ h ∈ generators, g * h = h * g := by
  classical
  intro g hg h hh
  simp [generators] at hg hh
  rcases hg with rfl | rfl <;> rcases hh with rfl | rfl
  · rfl
  · exact Z1Z2_commutes_Z2Z3
  · simpa using Z1Z2_commutes_Z2Z3.symm
  · rfl

/-- The subgroup generated by the repetition-code generators. -/
def subgroup : Subgroup (NQubitPauliGroupElement 3) :=
  Subgroup.closure generators

/-- Example usage: the generated subgroup is abelian, via `SubgroupLemmas`. -/
theorem subgroup_is_abelian :
    ∀ g ∈ subgroup, ∀ h ∈ subgroup, g * h = h * g := by
  -- `subgroup` is definitionaly `Subgroup.closure generators`.
  simpa [subgroup] using
    (Subgroup.abelian_closure_of_pairwise_commute (G := NQubitPauliGroupElement 3)
      generators generators_commute)

/-!
## No `-I` in the generated subgroup

This is a special case of the reusable CSS lemma with:
- Z-generators = `generators`
- X-generators = `∅`
-/

open NQubitPauliGroupElement

/-- Each generator is Z-type (I or Z on each qubit). -/
lemma generators_are_ZType :
    ∀ g, g ∈ generators → NQubitPauliGroupElement.IsZTypeElement g := by
  classical
  intro g hg
  rcases (by simpa [generators] using hg) with rfl | rfl <;>
    · constructor
      · rfl
      · intro i
        fin_cases i <;>
          simp [PauliOperator.IsZType, Z1Z2, Z2Z3, NQubitPauliOperator.set,
            NQubitPauliOperator.identity]

/-- The repetition-code subgroup does not contain −I (CSS lemma with empty X-generators). -/
lemma negIdentity_not_mem :
    negIdentity 3 ∉ subgroup := by
  -- Apply the generic CSS `-I` exclusion theorem with empty X-generators.
  have hX : ∀ x, x ∈ (∅ : Set (NQubitPauliGroupElement 3)) → IsXTypeElement x := by
    intro x hx; cases hx
  have hZX : ∀ z ∈ generators, ∀ x ∈ (∅ : Set (NQubitPauliGroupElement 3)), z * x = x * z := by
    intro z hz x hx; cases hx
  simpa [subgroup] using
    (CSS.negIdentity_not_mem_closure_union (n := 3) generators (∅ : Set (NQubitPauliGroupElement 3))
      generators_are_ZType hX hZX)

/-- The 3-qubit repetition code as a stabilizer group: abelian closure of Z₁Z₂ and Z₂Z₃, no −I. -/
noncomputable def stabilizerGroup : StabilizerGroup 3 :=
{ toSubgroup := subgroup
, is_abelian := by
    intro g h hg hh
    exact subgroup_is_abelian g hg h hh
, no_neg_identity := by
    simpa using negIdentity_not_mem }

/-!
## Logical operators
-/

/-- Logical X: X on all three qubits (X₁X₂X₃). -/
def logicalX : NQubitPauliGroupElement 3 :=
  ⟨0, NQubitPauliOperator.X 3⟩

/-- Logical Z: Z on all three qubits (Z₁Z₂Z₃). -/
def logicalZ : NQubitPauliGroupElement 3 :=
  ⟨0, NQubitPauliOperator.Z 3⟩

/-- Logical X and logical Z anticommute: X₁X₂X₃ and Z₁Z₂Z₃ anticommute at every qubit. -/
theorem logicalX_anticommutes_logicalZ : NQubitPauliGroupElement.Anticommute logicalX logicalZ :=
  NQubitPauliOperator.allX_allZ_anticommute 3 (by decide)

private lemma logicalX_commutes_Z1Z2 : logicalX * Z1Z2 = Z1Z2 * logicalX := by
  classical
  pauli_comm_even_anticommutes
  have hfilter :
      (Finset.univ.filter
            (NQubitPauliGroupElement.anticommutesAt (n := 3) logicalX.operators Z1Z2.operators)) =
        ({0, 1} : Finset (Fin 3)) := by
    ext i; fin_cases i <;>
      simp [Finset.mem_filter, NQubitPauliGroupElement.anticommutesAt, logicalX, Z1Z2,
        NQubitPauliOperator.X, NQubitPauliOperator.set, NQubitPauliOperator.identity,
        PauliOperator.mulOp]
  simp [hfilter]

private lemma logicalX_commutes_Z2Z3 : logicalX * Z2Z3 = Z2Z3 * logicalX := by
  classical
  pauli_comm_even_anticommutes
  have hfilter :
      (Finset.univ.filter
            (NQubitPauliGroupElement.anticommutesAt (n := 3) logicalX.operators Z2Z3.operators)) =
        ({1, 2} : Finset (Fin 3)) := by
    ext i; fin_cases i <;>
      simp [Finset.mem_filter, NQubitPauliGroupElement.anticommutesAt, logicalX, Z2Z3,
        NQubitPauliOperator.X, NQubitPauliOperator.set, NQubitPauliOperator.identity,
        PauliOperator.mulOp]
  simp [hfilter]

/-- Logical X commutes with every element of the stabilizer. -/
theorem logicalX_mem_centralizer : logicalX ∈ centralizer stabilizerGroup := by
  rw [StabilizerGroup.mem_centralizer_iff]
  intro h hh
  refine Subgroup.closure_induction (p := fun g _ => g * logicalX = logicalX * g)
    (fun g hg => ?_)
    (by simp only [NQubitPauliGroupElement.one_mul, NQubitPauliGroupElement.mul_one])
    (fun x y _ _ hx hy => ?_) (fun x _ h => ?_) hh
  · simp [generators] at hg
    rcases hg with rfl | rfl
    · exact logicalX_commutes_Z1Z2.symm
    · exact logicalX_commutes_Z2Z3.symm
  · calc (x * y) * logicalX = x * (y * logicalX) := by rw [NQubitPauliGroupElement.mul_assoc]
    _ = x * (logicalX * y) := by rw [hy]
    _ = (x * logicalX) * y := by rw [← NQubitPauliGroupElement.mul_assoc]
    _ = (logicalX * x) * y := by rw [hx]
    _ = logicalX * (x * y) := by rw [NQubitPauliGroupElement.mul_assoc]
  · have H : (x⁻¹ * logicalX) * x = (logicalX * x⁻¹) * x := by
      rw [NQubitPauliGroupElement.mul_assoc, ← h, inv_mul_cancel_left,
        NQubitPauliGroupElement.mul_assoc, inv_mul_cancel, NQubitPauliGroupElement.mul_one]
    exact mul_right_cancel H

/-- Logical X is X-type (X on every qubit). -/
lemma logicalX_is_XType : NQubitPauliGroupElement.IsXTypeElement logicalX := by
  constructor
  · rfl
  · intro i
    fin_cases i <;> simp [logicalX, NQubitPauliOperator.X, PauliOperator.IsXType]

private lemma logicalZ_commutes_Z1Z2 : logicalZ * Z1Z2 = Z1Z2 * logicalZ := by
  pauli_comm_componentwise [logicalZ, Z1Z2]
  all_goals simp only [NQubitPauliOperator.Z]

private lemma logicalZ_commutes_Z2Z3 : logicalZ * Z2Z3 = Z2Z3 * logicalZ := by
  pauli_comm_componentwise [logicalZ, Z2Z3]
  all_goals simp only [NQubitPauliOperator.Z]

/-- Logical Z commutes with every element of the stabilizer. -/
theorem logicalZ_mem_centralizer : logicalZ ∈ centralizer stabilizerGroup := by
  rw [StabilizerGroup.mem_centralizer_iff]
  intro h hh
  refine Subgroup.closure_induction (p := fun g _ => g * logicalZ = logicalZ * g)
    (fun g hg => ?_)
    (by simp only [NQubitPauliGroupElement.one_mul, NQubitPauliGroupElement.mul_one])
    (fun x y _ _ hx hy => ?_) (fun x _ h => ?_) hh
  · simp [generators] at hg
    rcases hg with rfl | rfl
    · exact logicalZ_commutes_Z1Z2.symm
    · exact logicalZ_commutes_Z2Z3.symm
  · calc (x * y) * logicalZ = x * (y * logicalZ) := by rw [NQubitPauliGroupElement.mul_assoc]
    _ = x * (logicalZ * y) := by rw [hy]
    _ = (x * logicalZ) * y := by rw [← NQubitPauliGroupElement.mul_assoc]
    _ = (logicalZ * x) * y := by rw [hx]
    _ = logicalZ * (x * y) := by rw [NQubitPauliGroupElement.mul_assoc]
  · have H : (x⁻¹ * logicalZ) * x = (logicalZ * x⁻¹) * x := by
      rw [NQubitPauliGroupElement.mul_assoc, ← h, inv_mul_cancel_left,
        NQubitPauliGroupElement.mul_assoc, inv_mul_cancel, NQubitPauliGroupElement.mul_one]
    exact mul_right_cancel H

/-- Logical X ∉ subgroup (witness: logical Z in centralizer, anticommutes with logical X). -/
theorem logicalX_not_mem_subgroup : logicalX ∉ subgroup :=
  not_mem_stabilizer_of_anticommutes_centralizer stabilizerGroup logicalX logicalZ
    logicalZ_mem_centralizer logicalX_anticommutes_logicalZ

/-- Logical Z ∉ subgroup (witness: logical X in centralizer, anticommutes with logical Z). -/
theorem logicalZ_not_mem_subgroup : logicalZ ∉ subgroup :=
  not_mem_stabilizer_of_anticommutes_centralizer stabilizerGroup logicalZ logicalX
    logicalX_mem_centralizer (anticommute_symm logicalX logicalZ logicalX_anticommutes_logicalZ)

end RepetitionCode3
end StabilizerGroup

end Quantum
